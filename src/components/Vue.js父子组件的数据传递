

一丶父组件向子组件的传递数据

# props 

定义在子组件中，作为父组件向子组件的传递数据的桥梁，只有子组件定义了这个属性，props: ['someMessgae']
表示子组件愿意“听”父组件的someMessage信息。

Step1 父组件引入子组件
import ComponentA from './components/ComponentA'



Step2 在父组件里面定义子组件

components: {'ComponentA'}



Step3   在父组件里面使用子组件

<component-a></component-a>   //注意写成横杠的形式  不要写成驼峰的形式



Step4 就此在父组件里面引入一个子组件，已经完毕。下面进行父组件向子组件传递数据，在父组里面

<component-a messagefromfather=“你好我是父组件传递给你的信息”></component-a>


Step5 子组件写法

export default {
	data () {
		//...
	},
	props: ['messagefromfather'],
	methods: {
		//.....
	}
}


注意：从父组件传递过来的messagefromfather 直接用this.messagefromfather就可以获取到





二丶在子组件里监听父组件的方法(子组件向父组件传递数据)

我们可以使用v-on方法

Step1 在父组件的定义一个，自定义方法

<component-a v-on:child-tell-me-something="listenToMyBoy"></component-a>



Step2 在父组件里面定义listenToMyBoy方法

methods: {
	listenToMyBoy (msg) {    //msg 子组件传来的数据
		console.log(msg);  //
	}
}


Step3  子组件触发事件

this.$emit('child-tell-me-something',this.msg);  //参数二是子组件想传给父组件的信息





# 编译作用域

在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为：
============================================================================

<child-component>
  {{ message }}
</child-component>
============================================================================
message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：

父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。

一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：
============================================================================

<!-- 无效 -->
<child-component v-show="someChildProperty"></child-component>
=============================================================================

假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。

如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：
==============================================================================
Vue.component('child-component', {
  // 有效，因为是在正确的作用域内
  template: '<div v-show="someChildProperty">Child</div>',
  data: function () {
    return {
      someChildProperty: true
    }
  }
})
==============================================================================
类似地，分发内容是在父作用域内编译。










# 单个Slot

除非子组件模板里面包含至少一个<slot>插口，否则父组件里面的内容将会被丢弃。当子组件模板只有一个没有
属性的slot时，父组件整个内容片段将插入到slot所在的DOM位置，并替换掉slot标签本身。

最初在<slot>标签里面的内容都被视为备用内容。备用内容在子组件的作用域里面编译，并且只有在宿主元素为空
时，并没有要插入内容时才会显示备用内容。

假定 my-component 组件有下面模板：
===========================================================================
<div>
  <h2>我是子组件的标题</h2>
  <slot>
    只有在没有要分发的内容时才会显示。
  </slot>
</div>
===========================================================================

父组件模版：
===========================================================================
<div>
  <h1>我是父组件的标题</h1>
  <my-component>
    <p>这是一些初始内容</p>
    <p>这是更多的初始内容</p>
  </my-component>
</div>
===========================================================================

渲染结果：
===========================================================================
<div>
  <h1>我是父组件的标题</h1>
  <div>
    <h2>我是子组件的标题</h2>
    <p>这是一些初始内容</p>
    <p>这是更多的初始内容</p>
  </div>
</div>
============================================================================







# 具名Slot

<slot>元素可以用一个特殊的属性name来配置如何分发内容。多个slot可以有不同的名字。具名slot将匹配内容
片段中有对应slot特性的元素。

仍然可以有一个匿名的slot，它时默认slot，作为找不到内容片段的备用插槽。如果没有 默认的slot，这些找不到
匹配的内容片段将被抛弃。


例如，假定我们有一个 app-layout 组件，它的模板为：
==============================================================================
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
==============================================================================

父组件模版：
===============================================================================
<app-layout>
  <h1 slot="header">这里可能是一个页面标题</h1>
  <p>主要内容的一个段落。</p>
  <p>另一个主要段落。</p>
  <p slot="footer">这里有一些联系信息</p>
</app-layout>
===============================================================================

渲染结果为：
===============================================================================
<div class="container">
  <header>
    <h1>这里可能是一个页面标题</h1>
  </header>
  <main>
    <p>主要内容的一个段落。</p>
    <p>另一个主要段落。</p>
  </main>
  <footer>
    <p>这里有一些联系信息</p>
  </footer>
</div>
================================================================================
在组合组件时，内容分发 API 是非常有用的机制。







# 作用域插槽

作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。

在子组件中，只需要将数据传递到插槽，就像你将prop传递给组件一样：
==================================================================================

<div class="child">
  <slot text="hello from child"></slot>
</div>
==================================================================================

在父级中，具有特殊属性的scope的<template>元素，表示它是作用域插槽的模板。scope的值对应一个临时
变量名，此变量接收从子组件传递的prop对象：
==================================================================================

<div class="parent">
  <child>
    <template scope="props">
      <span>hello from parent</span>
      <span>{{ props.text }}</span>
    </template>
  </child>
</div>
===================================================================================

如果我们渲染以上结果，得到的输出会是：
==================================================================================
<div class="parent">
  <div class="child">
    <span>hello from parent</span>
    <span>hello from child</span>
  </div>
</div>
====================================================================================

作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：
====================================================================================
<my-awesome-list :items="items">
  <!-- 作用域插槽也可以是具名的 -->
  <template slot="item" scope="props">
    <li class="my-fancy-item">{{ props.text }}</li>
  </template>
</my-awesome-list>
===================================================================================

列表组件的模板：
===================================================================================
<ul>
  <slot name="item"
    v-for="item in items"
    :text="item.text">
    <!-- 这里写入备用内容 -->
  </slot>
</ul>
===================================================================================








动态组件


通过使用保留的<component>元素，动态的绑定到它的is特性，我们可以让多个组件使用同一个挂载点，
并动态切换：
===================================================================================
var vm = new Vue({
	el: '#example',
	data: {
		currentView: 'home'
	},
	components: {
			home: { /* ... */ },
			posts: { /* ... */ },
			archive: { /* ... */ }
	}
})
-----------------------------------------------------------------------------------


component v-bind:is="currentView">
  <!-- 组件在 vm.currentview 变化时改变！ -->
</component>
===================================================================================

也可以直接绑定到组件对象上：
===================================================================================
var Home = {
	template: '<p>	Welcome home!</p>'
}

var vm = new Vue({
	el: '#example',
	data: {
		currentView: Home
	}
})
====================================================================================









# keep-alive

如果把切出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令参数：
=====================================================================================

keep-alive>
  <component :is="currentView">
    <!-- 非活动组件将被缓存！ -->
  </component>
</keep-alive>
=====================================================================================










杂项

# 编写可复用的组件

在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。

Vue 组件的 API 来自三部分 - props, events 和 slots ：

	1.props允许外部环境传递数据给组件

	2.Event允许触发外部环境的副作用

	3.Slots允许外部环境将额外的内容组合在组件中


使用v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：
==================================================================================

<my-component
  :foo="baz"
  :bar="qux"
  @event-a="doThis"
  @event-b="doThat"
>
  <img slot="icon" src="...">
  <p slot="main-text">Hello!</p>
</my-component>
==================================================================================




# 子组件索引

尽管有 props 和 events ，但是有时仍然需要在JavaScript中直接访问子组件，为此可以使用ref为子组件指定
一个索引ID。例如：
===================================================================================

<div id="parent">
  <user-profile ref="profile"></user-profile>
</div>
-----------------------------------------------------------------------------------

var parent = new Vue({el: '#parent'})
//访问子组件
var child = parent.$refs.profile
===================================================================================
当ref 和 v-for一起使用时，ref是一个数组或对象，包含相应的子组件。

	！$refs只在组件渲染完成后填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。





# 异步组件

在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。
Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：
====================================================================================
Vue.compoment('async-example',function(resolve,reject) {
	setTieout(function() {
		//Pass the component definition to the resolve callback
		resolve({
			template: '<div>I am async!</div>'
		})
	},1000)
})
=====================================================================================
工厂函数接受一个resolve回调，在收到从服务器下载组件定义时调用。也可以调用reject(reason)指定加载失败。
这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能：
=====================================================================================

Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 require 语法告诉 webpack
  // 自动将编译后的代码分割成不同的块，
  // 这些块将通过 Ajax 请求自动下载。
  require(['./my-async-component'], resolve)
})
=====================================================================================
你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数：

ue.component(
  'async-webpack-example',
  () => import('./my-async-component')
)
=====================================================================================










# 组件的命名约定

当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。
=====================================================================================
// 在组件定义中
components: {
  // 使用 kebab-case 形式注册
  'kebab-cased-component': { /* ... */ },
  // register using camelCase
  'camelCasedComponent': { /* ... */ },
  // register using TitleCase
  'TitleCasedComponent': { /* ... */ }
}
======================================================================================

在 HTML 模版中，请使用 kebab-case 形式：
======================================================================================

<!-- 在HTML模版中始终使用 kebab-case -->
<kebab-cased-component></kebab-cased-component>
<camel-cased-component></camel-cased-component>
<title-cased-component></title-cased-component>
======================================================================================

当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：
======================================================================================

<!-- 在字符串模版中可以用任何你喜欢的方式! -->
<my-component></my-component>
<myComponent></myComponent>
<MyComponent></MyComponent>
=======================================================================================
如果组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合：


<my-component/>


当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。









# 递归组件

组件在它的模本内可以递归调用它自己，不过，只有当它有name选项时才可以：
=============================================================================
name: 'unique-name-of-my-component'
=============================================================================
当你利用Vue.component全局注册了一个组件，全局的ID作为组件的name选项，被自动设置
==============================================================================

Vue.component('unique-name-of-my-component',{
	//...
})
==============================================================================

如果你不谨慎, 递归组件可能导致死循环:
==============================================================================
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
==============================================================================
上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 v-if 并让他最终返回 false )。








# 组件间的循环引用Circular References Between Components

假设你正在构建一个文件目录树，像在Finder或文件资源管理器中。你可能有一个 tree-folder组件:
===============================================================================
<p>
  <span>{{ folder.name }}</span>
  <tree-folder-contents :children="folder.children"/>
</p>
================================================================================

然后 一个tree-folder-contents组件：
================================================================================
<ul>
  <li v-for="child in children">
    <tree-folder v-if="child.children" :folder="child"/>
    <span v-else>{{ child.name }}</span>
  </li>
</ul>
=================================================================================
当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点–这点是矛盾的。当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾，如果你是这样做的，就不用继续往下看了。
然而，如果你使用诸如Webpack或者Browserify之类的模块化管理工具来requiring/importing组件的话，就会报错了：

Failed to mount component: template or render function not defined.


为了解释为什么会报错，简单的将上面两个组件称为 A 和 B ，模块系统看到它需要 A ，但是首先 A 需要 B ，
但是 B 需要 A， 而 A 需要B，陷入了一个无限循环，因此不知道到底应该先解决哪个。要解决这个问题，我们需要在其中一个组件中（比如 A ）告诉模块化管理系统，“A 虽然需要 B ，但是不需要优先导入 B”


在我们的例子中，我们选择在tree-folder 组件中来告诉模块化管理系统循环引用的组件间的处理优先级，我们知道引起矛盾的子组件是tree-folder-contents，所以我们在beforeCreate 生命周期钩子中去注册它：
=================================================================================
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
}
==================================================================================








# 内联模板

如果子组件有inline-template特性，组件就将它的内容当作它的模板，而不是把它当做分发内容。
这让模板更灵活。
=================================================================================
<my-component inline-template>
  <div>
    <p>These are compiled as the component's own template.</p>
    <p>Not parent's transclusion content.</p>
  </div>
</my-component>
==================================================================================
但是 inline-template 让模板的作用域难以理解。
最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。







# x-Templates

另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个id。例如：
=================================================================================
<script type="text/x-template" id="hello-world-template">
  <p>Hello hello hello</p>
</script>
---------------------------------------------------------------------------------

Vue.component('hello-world', {
  template: '#hello-world-template'
})
==================================================================================

这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。





# 对低开销的静态组件使用v-once

尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：
==================================================================================
Vue.component('terms-of-service', {
  template: '\
    <div v-once>\
      <h1>Terms of Service</h1>\
      ... a lot of static content ...\
    </div>\
  '
})
===================================================================================


























 












































































